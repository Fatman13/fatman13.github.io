<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 技术 | Fatman13]]></title>
  <link href="http://Fatman13.github.io/blog/categories/ji-zhu/atom.xml" rel="self"/>
  <link href="http://Fatman13.github.io/"/>
  <updated>2014-02-27T20:26:07+08:00</updated>
  <id>http://Fatman13.github.io/</id>
  <author>
    <name><![CDATA[Fatman13]]></name>
    <email><![CDATA[tctctcly@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何使用Jacoco远程统计tomcat服务的覆盖率]]></title>
    <link href="http://Fatman13.github.io/blog/2014/02/27/ru-he-shi-yong-jacocoyuan-cheng-tong-ji-tomcatfu-wu-de-fu-gai-lu/"/>
    <updated>2014-02-27T20:18:00+08:00</updated>
    <id>http://Fatman13.github.io/blog/2014/02/27/ru-he-shi-yong-jacocoyuan-cheng-tong-ji-tomcatfu-wu-de-fu-gai-lu</id>
    <content type="html"><![CDATA[<p>本文将简单介绍如何使用<code>Jacoco</code>生成远程<code>tomcat</code>服务的覆盖率报告。<br/>
(<em>注：使用<code>jacoco</code>打开远程服务端口，有一定安全风险。</em>)</p>

<!--more-->


<h1>软件安装</h1>

<ul>
<li><a href="http://ant.apache.org/bindownload.cgi">Ant</a></li>
<li><a href="http://www.eclemma.org/jacoco/">Jacoco</a></li>
</ul>


<h1>远程Tomcat服务配置</h1>

<ul>
<li><code>sh shutdown.sh</code>先关闭<code>tomcat</code>服务。</li>
<li>修改<code>bin/catalina.sh</code>中<code>JAVA_OPTS</code>的配置。</li>
</ul>


<p>``` sh</p>

<h1>-javaagent: 的后面跟jacoco的安装路径</h1>

<h1>includes= 选项，选择你要覆盖率的服务</h1>

<h1>port= 选项，选择你要打开的端口</h1>

<h1>address= 选项，tomcat服务所在机器的ip地址（如果想在跟tomcat服务同一台机器上执行ant任务的话，需要改为127.0.0.1）</h1>

<p>JAVA_OPTS=&ldquo;-javaagent:/path/to/your/jacoco_0.6.4/lib/jacocoagent.jar=includes=com.baidu.*,output=tcpserver,port=8893,address=10.81.14.77&rdquo;
<code>``
-</code>sh startup.sh<code>重新启动</code>tomcat`服务。</p>

<h1>本地Ant任务配置</h1>

<ul>
<li>配置<code>build.xml</code>。</li>
</ul>


<p>``` xml
&lt;?xml version=&ldquo;1.0&rdquo; ?>
<project name="Lengyu" xmlns:jacoco="antlib:org.jacoco.ant" default="jacoco"></p>

<pre><code>&lt;!--Jacoco的安装路径--&gt;
&lt;property name="jacocoantPath" value="/home/work/software/jacoco_0.6.4/lib/jacocoant.jar"/&gt;
&lt;!--最终生成.exec文件的路径，Jacoco就是根据这个文件生成最终的报告的--&gt;
&lt;property name="jacocoexecPath" value="/home/work/local/hudson_home/workspace/wg_merchant_oc_regression/jacoco.exec"/&gt;
&lt;!--生成覆盖率报告的路径--&gt;
&lt;property name="reportfolderPath" value="E:/Libs/coverage_ant_task/report/"/&gt;
&lt;!--远程tomcat服务的ip地址--&gt;
&lt;property name="server_ip" value="10.81.14.77"/&gt;
&lt;!--前面配置的远程tomcat服务打开的端口，要跟上面配置的一样--&gt;
&lt;property name="server_port" value="8893"/&gt;
&lt;!--源代码路径--&gt;
&lt;property name="checkOrderSrcpath" value="E:/Src/ordercenter/ordercenter-biz/src/main/java/" /&gt;
&lt;!--.class文件路径--&gt;
&lt;property name="checkOrderClasspath" value="E:/Src/ordercenter/ordercenter-biz/target/classes/com/baidu/ordercenter/service/Impl" /&gt;

&lt;!--让ant知道去哪儿找Jacoco--&gt;
&lt;taskdef uri="antlib:org.jacoco.ant" resource="org/jacoco/ant/antlib.xml"&gt;
    &lt;classpath path="${jacocoantPath}" /&gt;
&lt;/taskdef&gt;

&lt;!--dump任务:
    根据前面配置的ip地址，和端口号，
    访问目标tomcat服务，并生成.exec文件。--&gt;
&lt;target name="dump"&gt;
    &lt;jacoco:dump address="${server_ip}" reset="false" destfile="${jacocoexecPath}" port="${server_port}" append="true"/&gt;
&lt;/target&gt;

&lt;!--jacoco任务:
    根据前面配置的源代码路径和.class文件路径，
    根据dump后，生成的.exec文件，生成最终的html覆盖率报告。--&gt;
&lt;target name="report"&gt;
    &lt;delete dir="${reportfolderPath}" /&gt;
    &lt;mkdir dir="${reportfolderPath}" /&gt;

    &lt;jacoco:report&gt;
        &lt;executiondata&gt;
            &lt;file file="${jacocoexecPath}" /&gt;
        &lt;/executiondata&gt;

        &lt;structure name="JaCoCo Report"&gt;
            &lt;group name="Check Order related"&gt;          
                &lt;classfiles&gt;
                    &lt;fileset dir="${checkOrderClasspath}" /&gt;
                &lt;/classfiles&gt;
                &lt;sourcefiles encoding="gbk"&gt;
                    &lt;fileset dir="${checkOrderSrcpath}" /&gt;
                &lt;/sourcefiles&gt;
            &lt;/group&gt;
        &lt;/structure&gt;

        &lt;html destdir="${reportfolderPath}" encoding="utf-8" /&gt;         
    &lt;/jacoco:report&gt;
&lt;/target&gt;
</code></pre>

<p></project>
```</p>

<h1>生成覆盖率报告</h1>

<ul>
<li>执行<code>ant dump</code>。成功的话，应会有如下输出。</li>
</ul>


<p>```
[<a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x77;&#x6f;&#x72;&#x6b;&#x40;&#x73;&#116;&#48;&#x31;&#45;&#x65;&#x63;&#111;&#x6d;&#x2d;&#x6a;&#110;&#50;&#46;&#x73;&#116;&#48;&#49;&#46;&#98;&#x61;&#105;&#x64;&#x75;&#x2e;&#x63;&#x6f;&#x6d;">&#119;&#111;&#114;&#x6b;&#64;&#x73;&#116;&#48;&#49;&#45;&#101;&#x63;&#x6f;&#109;&#x2d;&#x6a;&#110;&#50;&#x2e;&#115;&#x74;&#48;&#49;&#46;&#98;&#x61;&#x69;&#100;&#117;&#46;&#x63;&#111;&#109;</a> ant]$ ant dump
Buildfile: /home/work/local/hudson_home/workspace/wg_merchant_oc_regression/ant/build.xml</p>

<p>dump:
[jacoco:dump] Connecting to /10.81.14.77:8893
[jacoco:dump] Dumping execution data to /home/work/local/hudson_home/workspace/wg_merchant_oc_regression/jacoco.exec</p>

<p>BUILD SUCCESSFUL
Total time: 0 seconds
```</p>

<ul>
<li>最后执行<code>ant report</code>。<code>jacoco</code>就会在你指定的路径生成覆盖率报告了。</li>
</ul>


<h1>附录</h1>

<ul>
<li>更多关于<code>Jacocoagent</code>以及各种<code>task</code>可以参考<a href="http://www.eclemma.org/jacoco/trunk/doc/ant.html">官方文档</a></li>
<li><code>Jenkins</code>的<code>Jacoco plugin</code>可以根据<code>.exec</code>文件直接生成覆盖率报告，并在<code>Jenkins</code>中生成图表等等。那样的话，<code>ant report</code>这个任务就没用了。</li>
<li>如有问题，可发email至<a href="mailto:lengyu@baidu.com">lengyu@baidu.com</a>。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在没有外网的机器上安装gem]]></title>
    <link href="http://Fatman13.github.io/blog/2014/02/27/ru-he-zai-mei-you-wai-wang-de-ji-qi-shang-an-zhuang-gem/"/>
    <updated>2014-02-27T20:16:00+08:00</updated>
    <id>http://Fatman13.github.io/blog/2014/02/27/ru-he-zai-mei-you-wai-wang-de-ji-qi-shang-an-zhuang-gem</id>
    <content type="html"><![CDATA[<p>本文将简单介绍如何在没有外网的机器上安装<code>Cucumber</code>小黄瓜自动化测所需的<code>gem</code>库。</p>

<!--more-->


<h1>1. 软件安装（Jenkins机器）</h1>

<ul>
<li>安装<code>Jumbo</code>。</li>
</ul>


<p><code>
bash -c "$( curl http://jumbo.baidu.com/install_jumbo.sh )"; source ~/.bashrc
</code></p>

<ul>
<li>安装<code>Ruby 1.9.3</code>。</li>
</ul>


<p><code>
jumbo install ruby
</code></p>

<ul>
<li>安装<code>svn</code>。</li>
</ul>


<p><code>
jumbo install subversion
</code></p>

<h1>2. 在无外网的Jenkins服务器（或者Slave机）上安装Gem</h1>

<ul>
<li>在jenkins机器上，选择一个合适的文件夹。从<code>svn</code>上下载小黄瓜所依赖的<code>gem</code>。</li>
</ul>


<p><code>
svn export https://svn.baidu.com/app-test/ecom/shifen/sf-crm/trunk/weigou/cuke_gems/
</code></p>

<ul>
<li><code>cd cuke_gems</code>至刚刚下载的文件夹中。运行如下指令，会先安装<code>bundler</code>这个<code>gem</code>。</li>
</ul>


<p><code>
gem install --local bundler-1.3.4.gem
</code></p>

<ul>
<li>安装完成后，运行以下指令。</li>
</ul>


<p><code>
bundle install --local
</code></p>

<h1>3. 添加新的Gem</h1>

<ul>
<li>如果需要添加新的gem的话，找一台有外网的机器。（如果Jenkins或者Slave机器是Linux机器，就得用Linux机器，是Windows就得用Windows机器。）</li>
<li>先<code>co</code>之前的<code>gem</code>库。</li>
</ul>


<p><code>
svn co https://svn.baidu.com/app-test/ecom/shifen/sf-crm/trunk/weigou/cuke_gems/
</code>
&ndash; <code>cd cuke_gems</code>至刚下载的文件夹中，修改<code>Gemfile</code>，添加新的<code>gem</code>。（最好能选定<code>gem</code>的版本）例如：</p>

<p>``` ruby
source &lsquo;<a href="http://rubygems.org">http://rubygems.org</a>&rsquo;</p>

<p>gem &lsquo;json&rsquo;, &lsquo;1.7.3&rsquo;
gem &lsquo;bundler&rsquo;, &lsquo;1.3.4&rsquo;</p>

<h1>添加新Gem示例 &lt;&mdash;&mdash;&mdash;</h1>

<p>gem &lsquo;new_gem&rsquo;, &lsquo;0.0.1&rsquo;</p>

<p>group :test do
  gem &lsquo;cucumber&rsquo;, &lsquo;1.2.1&rsquo;
  gem &lsquo;rspec&rsquo;, &lsquo;2.11.0&rsquo;
  gem &lsquo;httparty&rsquo;, &lsquo;0.8.3&rsquo;
  gem &lsquo;rest-client&rsquo;, &lsquo;1.6.7&rsquo;
end
<code>``
- 添加完成后，运行</code>bundle install<code>，然后运行</code>bundle package<code>。这样</code>bundler<code>就会生成新添加的</code>gem<code>的</code>.gem<code>文件以提供本地安装了。
- 把更新后的代码提交至</code>svn`。</p>

<p><code>
svn commit -m "add new gem(s)"
</code></p>

<ul>
<li>最后重复上文第2大点中的步骤，就能更新Jenkins机器上的<code>gem</code>库了。</li>
</ul>


<h1>附录</h1>

<ul>
<li><code>bundler</code>是给<code>gem</code>打包的一个<code>gem</code>，所以在上文中先安装了<code>bundler</code>，然后让<code>bundler</code>去本地安装其他的<code>gem</code>。</li>
<li>更多关于<code>Gemfile</code>的使用方法，可以参考<a href="http://bundler.io/">官方网站</a>。</li>
<li>所有<code>.gem</code>文件都可以在<a href="http://rubygems.org/">rubygems.org</a>上下载到。其中包括<code>gem</code>的所有历史版本。</li>
<li>如有更多问题，发送email至<a href="mailto:lengyu@baidu.com">lengyu@baidu.com</a>。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试桩使用指南]]></title>
    <link href="http://Fatman13.github.io/blog/2014/02/19/ce-shi-zhuang-shi-yong-zhi-nan/"/>
    <updated>2014-02-19T21:35:00+08:00</updated>
    <id>http://Fatman13.github.io/blog/2014/02/19/ce-shi-zhuang-shi-yong-zhi-nan</id>
    <content type="html"><![CDATA[<p>本文将简单介绍<code>测试桩</code>现有的一些功能以及如何使用<code>测试桩</code>提供的<code>API</code>接口。</p>

<!--more-->


<h1>测试桩简介</h1>

<p>现在测试桩使用<code>Django</code>框架，大致分为<code>mysite</code>，<code>jsonrpc</code>，<code>scaffolding</code>这3个模块。<br/>
（注：在项目的根目录使用了<code>python manage.py startapp [模块名]</code>这个命令创建了这些模块，模块化<code>Django</code>提供的服务）</p>

<ul>
<li><code>mysite</code>是项目的第一个模块。主要提供了kv以及商品库的几个接受jsonrpc请求的接口。<code>mysite</code>下的<code>urls.py</code>是定义<code>测试桩</code>各项API接口url的主入口。</li>
<li><code>jsonrpc</code>提供了几个发送jsonrpc请求的接口（mcpack封装），还有发送通用的jsonrpc请求的接口。（无mcpack封装，vanilla版jsonrpc请求）</li>
<li><code>scaffolding</code>主要负责提供制造各种mock商品的接口，便于自动化case的setup中，制造case所需的mock商品。</li>
</ul>


<h1>Chrome插件</h1>

<p>使用<code>chrome</code>的<code>cRest Client</code>插件可以手动向<code>测试桩</code>发送各种请求。</p>

<p><img src="http://i.imgur.com/oJEztF2.jpg" alt="" /></p>

<h1>Jsonrpc工具</h1>

<p>输入<code>测试桩</code>商品库地址<code>http://st01-ecom-jn2.st01.baidu.com:8890/serviceAPI/api</code>，选择api，method，并填入请求参数就可以手动给<code>测试桩</code>发送jsonrpc请求了。jsonrpc工具可在附件中下载。</p>

<p><img src="http://i.imgur.com/ALJTrbi.jpg" alt="" /></p>

<h1>1. Mysite接口</h1>

<p>（可试用jsonrpc工具手动访问这些接口，或者使用renliang开发的jsonrpc-client）</p>

<h3>1.1 ProductAPI/queryInfo 获取商品详情</h3>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/serviceAPI/api">http://st01-ecom-jn2.st01.baidu.com:8890/serviceAPI/api</a></li>
<li>ProductAPI</li>
<li>queryInfo</li>
<li>{&ldquo;products&rdquo;:[&ldquo;183019616&rdquo;],&ldquo;uc_id&rdquo;:29844}</li>
</ul>


<h3>1.2 PromotionAPI/query 获取促销详情</h3>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/serviceAPI/api">http://st01-ecom-jn2.st01.baidu.com:8890/serviceAPI/api</a></li>
<li>PromotionAPI</li>
<li>query</li>
<li>{&ldquo;promotion_id&rdquo;:&ldquo;3000&rdquo;,&ldquo;uc_id&rdquo;:29844}</li>
</ul>


<h3>1.3 StockAPI/updateIncrement 增减库存</h3>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/serviceAPI/api">http://st01-ecom-jn2.st01.baidu.com:8890/serviceAPI/api</a></li>
<li>StockAPI</li>
<li>updateIncrement</li>
<li>{&ldquo;uc_id&rdquo;:6195321,&ldquo;products&rdquo;:[{&ldquo;product_id&rdquo;:&ldquo;600528576&rdquo;,&ldquo;items&rdquo;:[{&ldquo;stock&rdquo;:-2,&ldquo;region&rdquo;:&ldquo;全国&rdquo;}]}]}</li>
</ul>


<h3>1.4 PromotionAPI/updateStockInc 增减促销库存</h3>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/serviceAPI/api">http://st01-ecom-jn2.st01.baidu.com:8890/serviceAPI/api</a></li>
<li>PromotionAPI</li>
<li>updateStockInc</li>
<li>{&ldquo;uc_id&rdquo;: 29844,&ldquo;product_outerid&rdquo;:&ldquo;F47&rdquo;,&ldquo;promotion_id&rdquo;:37,&ldquo;stock_inc&rdquo;:5}</li>
</ul>


<h1>2. kv接口</h1>

<p>（kv接口主要应用于验单时，查询该商品是否存在。新kv接口是一个新的技术优化，与老kv接口还并存着。。。）</p>

<h3>2.1 新kv接口</h3>

<p><a href="http://st01-ecom-jn2.st01.baidu.com:8890/serviceAPI/midpage/product/details?ids=183019611">http://st01-ecom-jn2.st01.baidu.com:8890/serviceAPI/midpage/product/details?ids=183019611</a></p>

<h3>2.2 老kv接口</h3>

<p><a href="http://st01-ecom-jn2.st01.baidu.com:8890/api/midpage/product/details?ids=183019611">http://st01-ecom-jn2.st01.baidu.com:8890/api/midpage/product/details?ids=183019611</a></p>

<h1>3. Scaffolding接口</h1>

<p>（主要用于各种商品库接口的mock数据的制造，便于自动化case的setup。）</p>

<h3>3.1 制造kv接口的返回值</h3>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/scaffolding/create/kv?product_id=77582589&amp;stock=0&amp;promotionId=1013">http://st01-ecom-jn2.st01.baidu.com:8890/scaffolding/create/kv?product_id=77582589&amp;stock=0&amp;promotionId=1013</a></li>
<li>(可以跟更多参数。参照<code>mysite/response/new_KV/new_kv_template.json</code>。)</li>
</ul>


<h3>3.2 制造老kv接口的返回值（老kv）</h3>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/scaffolding/create/oldkv?product_id=77582589&amp;merchantId=298440&amp;newPrice=100.00">http://st01-ecom-jn2.st01.baidu.com:8890/scaffolding/create/oldkv?product_id=77582589&amp;merchantId=298440&amp;newPrice=100.00</a></li>
<li>(可以跟更多参数。参照<code>mysite/response/KV/kv_template.json</code>。)</li>
</ul>


<h3>3.3 制造queryInfo接口的返回值</h3>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/scaffolding/create/ProductAPI/queryInfo?product_id=77582589&amp;active=0&amp;fid=1157">http://st01-ecom-jn2.st01.baidu.com:8890/scaffolding/create/ProductAPI/queryInfo?product_id=77582589&amp;active=0&amp;fid=1157</a></li>
<li>(可以跟更多参数。参照<code>mysite/response/ProductAPI/queryInfo/queryInfo_template.json</code>。)</li>
</ul>


<h3>3.4 制造query接口的返回值</h3>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/scaffolding/create/PromotionAPI/query?product_id=77582589&amp;active=0&amp;fid=1157">http://st01-ecom-jn2.st01.baidu.com:8890/scaffolding/create/PromotionAPI/query?product_id=77582589&amp;active=0&amp;fid=1157</a></li>
<li>(可以跟更多参数。参照<code>mysite/response/PromotionAPI/query/query_template.json</code>。)</li>
</ul>


<h1>4. Jsonrpc接口</h1>

<p>（用post方法，带着参数，访问这些接口。<code>测试桩</code>会代为发送jsonrpc请求，相当于一个接口级的jsonrpc工具。推荐使用上文提到的Chrome中<code>cRest Client</code>这个插件。使用post方法的话，Request entity中放请求的json串，或者其他参数。）</p>

<h3>4.1 vanilla示例（无mcpack封装，支持大多数jsonrpc的api）</h3>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/jsonrpc/vanilla/ProductAPI/queryInfo">http://st01-ecom-jn2.st01.baidu.com:8890/jsonrpc/vanilla/ProductAPI/queryInfo</a></li>
<li>{&ldquo;products&rdquo;:[&ldquo;183019611&rdquo;],&ldquo;uc_id&rdquo;:29844}</li>
</ul>


<h3>4.2 jsonrpc示例（有mcpack封装，只支持个别jsonrpc的api）</h3>

<h4>4.2.1 OrderInnerAPI/daigouCreateOrder（代购api）</h4>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/jsonrpc/send/OrderInnerAPI/daigouCreateOrder">http://st01-ecom-jn2.st01.baidu.com:8890/jsonrpc/send/OrderInnerAPI/daigouCreateOrder</a></li>
<li>{&ldquo;daigouOrder&rdquo;:{&ldquo;daigouId&rdquo;:1,&ldquo;passportId&rdquo;:&ldquo;1245&rdquo;,&ldquo;productIds&rdquo;:&ldquo;181835090&rdquo;,&ldquo;productCounts&rdquo;:&ldquo;1&rdquo;,&ldquo;customer&rdquo;:&ldquo;木根&rdquo;,&ldquo;mobile&rdquo;:&ldquo;12383846326&rdquo;,&ldquo;payStyle&rdquo;:&ldquo;DAIGOU&rdquo;,&ldquo;province&rdquo;:&ldquo;山东&rdquo;,&ldquo;city&rdquo;:&ldquo;济南市&rdquo;,&ldquo;district&rdquo;:&ldquo;大观区&rdquo;,&ldquo;town&rdquo;:&ldquo;白贤镇&rdquo;,&ldquo;districtId&rdquo;:&ldquo;120001&rdquo;,&ldquo;detailAddress&rdquo;:&ldquo;龙山路22号&rdquo;,&ldquo;needInvoice&rdquo;:&ldquo;true&rdquo;,&ldquo;invoiceTitle&rdquo;:&ldquo;百度中国&rdquo;},&ldquo;token&rdquo;:&ldquo;daigou_token_26e588a503074&rdquo;}</li>
</ul>


<h4>4.2.2 PostageAPI/addTemplate（添加运费模板api）</h4>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/jsonrpc/send/PostageAPI/addTemplate">http://st01-ecom-jn2.st01.baidu.com:8890/jsonrpc/send/PostageAPI/addTemplate</a></li>
<li>{&ldquo;name&rdquo;:&ldquo;运费模板名称&rdquo;,&ldquo;ucId&rdquo;:29844,&ldquo;outerId&rdquo;:null,&ldquo;assumer&rdquo;:&ldquo;SELLER&rdquo;,&ldquo;valuation&rdquo;:&ldquo;QUANTITY&rdquo;,&ldquo;consignAreaId&rdquo;:&ldquo;110101&rdquo;,&ldquo;lastModify&rdquo;:&ldquo;2014-01-02 19:06:01&rdquo;,&ldquo;shippingMethodList&rdquo;:[{&ldquo;name&rdquo;:&ldquo;COD&rdquo;,&ldquo;defaultStartStandards&rdquo;:&ldquo;1&rdquo;,&ldquo;defaultStartFees&rdquo;:&ldquo;10.00&rdquo;,&ldquo;defaultAddStandards&rdquo;:&ldquo;1&rdquo;,&ldquo;defaultAddFees&rdquo;:&ldquo;4.00&rdquo;,&ldquo;regionGroupList&rdquo;:[]}]}</li>
</ul>


<h4>4.2.3 PostageAPI/deleteTemplate（删除运费模板api）</h4>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/jsonrpc/send/PostageAPI/deleteTemplate">http://st01-ecom-jn2.st01.baidu.com:8890/jsonrpc/send/PostageAPI/deleteTemplate</a></li>
<li>109</li>
</ul>


<h4>4.2.4 DeliveryRegionsAPI/updateDeliveryRegions（更新配送范围api）</h4>

<ul>
<li><a href="http://st01-ecom-jn2.st01.baidu.com:8890/jsonrpc/send/DeliveryRegionsAPI/updateDeliveryRegions">http://st01-ecom-jn2.st01.baidu.com:8890/jsonrpc/send/DeliveryRegionsAPI/updateDeliveryRegions</a></li>
<li>0</li>
</ul>


<h1>总结</h1>

<p>如有问题可以发送邮件至<a href="mailto:lengyu@baidu.com">lengyu@baidu.com</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何整合Cucumber小黄瓜至Jenkins持续集成服务器]]></title>
    <link href="http://Fatman13.github.io/blog/2014/02/17/ru-he-zheng-he-cucumberxiao-huang-gua-zhi-jenkinschi-xu-ji-cheng-fu-wu-qi/"/>
    <updated>2014-02-17T21:18:00+08:00</updated>
    <id>http://Fatman13.github.io/blog/2014/02/17/ru-he-zheng-he-cucumberxiao-huang-gua-zhi-jenkinschi-xu-ji-cheng-fu-wu-qi</id>
    <content type="html"><![CDATA[<p>本文将简单介绍如何将<code>Cucumber</code>小黄瓜的测试case整合到你的<code>Jenkins CI服务器</code>中。</p>

<!--more-->


<h1>软件安装</h1>

<p>以Windows工作机为例<br/>
&ndash; JDK或者JRE（记得设置JAVA_HOME这个环境变量）<br/>
&ndash; git（如果你已经安装了<a href="http://railsinstaller.org/">RailsInstaller</a>，里面是包含git的）<br/>
&ndash; 下载最新稳定版的<a href="http://mirrors.jenkins-ci.org/war/latest/jenkins.war">Jenkins</a></p>

<h1>本地建立git代码库</h1>

<p>下载，解压源代码，打开命令行，cd至刚解压的文件夹中，运行以下命令。</p>

<p><code>
git init
git add .
git commit -m "initial commit"
</code></p>

<h1>本地配置和运行Jenkins</h1>

<ul>
<li>拷贝<code>Jenkins</code>的<code>war包</code>至你想要的文件夹，打开命令行，cd至那个文件夹。</li>
<li>运行<code>java -Dfile.encoding=UTF-8 -jar jenkins.war</code>。</li>
<li>在网页浏览器中打开<code>http://localhost:8080/configureSecurity/</code>，按下图中的配置以后点击<code>Save</code>。</li>
</ul>


<p><img src="http://i.imgur.com/ea5IK3k.jpg" alt="" /></p>

<ul>
<li>打开<code>http://localhost:8080/pluginManager/available</code>，勾选<code>Source Code Management</code>下的<code>Git Plugin</code>和<code>Build Tools</code>下的<code>Rake plugin</code>。点击<code>Download now and install after restart</code>。</li>
<li>等待Jenkins安装插件，失败的话再重新装。安装完成后<code>ctrl+c</code>杀掉进程，并重新运行<code>Jenkins</code>。</li>
<li>打开<code>http://localhost:8080/view/All/newJob</code>。填入你想要的Job名称，选择<code>Build a free-style software project</code>。点击<code>OK</code>。</li>
<li>打开<code>http://localhost:8080/job/[job名称]/configure</code>。</li>
<li>在<code>Source Code Management</code>下，选择<code>Git</code>。并在<code>Repository URL</code>中填上小黄瓜case所在的文件夹地址。如下图。</li>
</ul>


<p><img src="http://i.imgur.com/OVjhttE.jpg" alt="" /></p>

<ul>
<li>在<code>Build Triggers</code>中勾选<code>Trigger builds remotely</code>。填一个你喜欢的token。这样这个job就可以被远程执行了。以下图为例，在浏览器中输入<code>http://localhost:8080/job/wg_merchant_oc_regression/build?token=lengyu</code>就能执行这个job了。</li>
</ul>


<p><img src="http://i.imgur.com/YhfCOzS.jpg" alt="" /></p>

<ul>
<li>在<code>Build</code>下，点击<code>Add Build Step</code>，并选择<code>Invoke Rake</code>。点击<code>Advanced</code>。配置如下图。<code>features</code>是一个<code>rake task</code>，需要在前面<code>Repository URL</code>目录中配置<code>Rakefile</code>，参见上传的代码。</li>
</ul>


<p><img src="http://i.imgur.com/V7AfNPc.jpg" alt="" /></p>

<h1>总结</h1>

<p>在<code>git plugin</code>和<code>rake plugin</code>的帮助下，轻轻松松就能将小黄瓜整合到<code>jenkins</code>中。如有问题可发送邮件至<a href="mailto:lengu@baidu.com">lengyu@baidu.com</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用Cucumber小黄瓜做结算中心数据校验自动化]]></title>
    <link href="http://Fatman13.github.io/blog/2014/02/15/ru-he-shi-yong-cucumberxiao-huang-gua-zuo-jie-suan-zhong-xin-shu-ju-xiao-yan-zi-dong-hua/"/>
    <updated>2014-02-15T15:53:00+08:00</updated>
    <id>http://Fatman13.github.io/blog/2014/02/15/ru-he-shi-yong-cucumberxiao-huang-gua-zuo-jie-suan-zhong-xin-shu-ju-xiao-yan-zi-dong-hua</id>
    <content type="html"><![CDATA[<p>本文将简单介绍如何使用<code>小黄瓜</code>来实结算中心数据比对的自动化。如果你对小黄瓜还没有初步认识的话，推荐阅读我之前写的一篇<a href="http://tauntaunslayer13.me/blog/2014/01/26/ru-he-shi-yong-capybarahe-cucumbershi-xian-ye-mian-ji-bie-zi-dong-hua/">文章</a>。</p>

<!--more-->


<h1>运行自动化</h1>

<p>按照惯例，下载代码，解压，打开命令行，切换到解压后的文件夹中。<br/>
运行<code>bundle install</code>。<br/>
运行<code>cucumber features/wgpc_sc.feature</code>，运行成功的话，应该能看见如下输出。</p>

<p><img src="http://i.imgur.com/oPyqlVY.jpg" alt="" /></p>

<p>注意这个case挂掉了，因为<code>jianzhong</code>2月14号的数据跟线上数据校验后有出入。输出中浅蓝色的字体（{&ldquo;540&rdquo;=>[46.0, 0.0]}）为账户金额有出入的商家id以及<code>jianzhong</code>与线上数据金额的差额。</p>

<h1>feature文档</h1>

<p>这次的feature文档简单很多。如对feature文档中的关键词存有疑惑，可参考我之前写的这篇<a href="http://tauntaunslayer13.me/blog/2014/02/13/ru-he-shi-yong-xiao-huang-gua-lai-zuo-jie-kou-ji-ce-shi/">文章</a>。</p>

<p>``` cucumber
Feature: 比对结算数据
  为了保证结算数据中各个资金帐户余额的准确性，跟建忠计算的数据进行验对。</p>

<p>  Scenario: 校验逻辑</p>

<pre><code>Given 我读取"./data/sc/2014-02-13.xls"建忠excel文件中的数据
And 我打开"http://settlement.weigou.baidu.com/macount/account_info?merchantId="线上结算中心网站并抓取结算数据
When 我比对这二组数据
Then 我将会生成校验报告并评估此次校验
</code></pre>

<p>```</p>

<p>整个比对过程大致为，打开<code>jianzhong</code>的excel文件，打开线上的结算中心，并抓取线上结算中心网页上的数据，并跟<code>jianzhong</code>的数据进行比对，如有出入，打印有出入的商家id以及2份数据余额的差额并断言。（注：本来想自动发email的，但是mail这个gem所依赖的mime-type这个gem跟cucumber也不知道是capybara用到的mime-type的版本好像有冲突。望高人留言指点。）</p>

<h1>代码详解</h1>

<p>``` ruby
Given /^我读取"(.*?)&ldquo;建忠excel文件中的数据$/ do |excel_file|
  # 使用spreadsheet这个gem来读取xls文件
  sc_file = Spreadsheet.open excel_file
  # 选择记录各资金账户余额的一张sheet
  sc_sheet = sc_file.worksheet 2
  # @sc_data_jianzhong以商家id为key，对应value为长度为2的一个数组
  # 数组中第1个值为用户担保帐余额，第2个是待结算账户余额
  @sc_data_jianzhong = Hash.new
  counter = 0
  # 读取每一行
  sc_sheet.each do |row|</p>

<pre><code># 跳过第一行，其实不跳也没关系
counter += 1
if counter == 1
  next
end 
# row[2]就是用户担保帐余额，row[3]是待结算账户余额
@sc_data_jianzhong[row[0]] = Array.new
@sc_data_jianzhong[row[0]] &lt;&lt; row[2]    
@sc_data_jianzhong[row[0]] &lt;&lt; row[3]
</code></pre>

<p>  end
end
```</p>

<p>从excel文件里面读取<code>jianzhong</code>结算的结算数据，并保存到<code>@sc_data_jianzhong</code>这个变量中。</p>

<p>``` ruby
Given /^我打开"(.*?)&ldquo;线上结算中心网站并抓取结算数据$/ do |sc_url|
  # 访问结算中心线上环境
  visit sc_url
  # 算一下一共有多少行商家
  count = page.all(&lsquo;table tr&rsquo;).count
  @sc_data_yanghu = Hash.new
  # 有多少行，就loop多少次
  count.times do |i|</p>

<pre><code># 跳过第一行，其实也可以不跳
if i == 0
  next
end 
# 用xpath选到每一行，拿他的text。
row = find(:xpath, "(//tr)[" + (i + 1).to_s + "]").text.split
@sc_data_yanghu[row[1]] = Array.new
# row[4]为用户担保帐余额，row[5]为待结算账户余额
@sc_data_yanghu[row[1]] &lt;&lt; row[4][1, row[4].length]
@sc_data_yanghu[row[1]] &lt;&lt; row[5][1, row[5].length]
</code></pre>

<p>  end
end
```</p>

<p>使用<code>selenium-webdriver</code>配合<code>capybara</code>打开结算中心线上环境。并抓取页面上的数据，保存至<code>@sc_data_yanghu</code>这个参数中。</p>

<p>``` ruby
When /^我比对这二组数据$/ do
  # 数据比对结果
  @result = Hash.new
  # 比对@sc_data_yanghu和@sc_data_jianzhong，写的比较死，不是最灵活
  @sc_data_yanghu.each do |key, value|</p>

<pre><code>if @sc_data_jianzhong.has_key?(key)
  if @sc_data_jianzhong[key][0].to_f != value[0].delete(',').to_f || @sc_data_jianzhong[key][1].to_f != value[1].delete(',').to_f
    @result[key] = Array.new
    # 现在想来可能这个delete(',')的处理放在上面可能比较好。
    @result[key] &lt;&lt; (@sc_data_jianzhong[key][0].to_f - value[0].delete(',').to_f)
    @result[key] &lt;&lt; (@sc_data_jianzhong[key][1].to_f - value[1].delete(',').to_f)
  end
end
</code></pre>

<p>  end
end
```</p>

<p>比对@sc_data_yanghu和@sc_data_jianzhong里面的数据，如果数据有出入的话，保存商家id至<code>@result</code>中，然后计算2份数据之间的差额，差额越大bug的可能性也越大，大概。。。</p>

<p>``` ruby
Then /^我将会生成校验报告并评估此次校验$/ do
  # 本来想自动发email的，但是这个mail的依赖好像有冲突，求高人指点
  # Mail.deliver do
  #   from     &lsquo;<a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#113;&#x61;&#45;&#x61;&#x75;&#116;&#x6f;&#x6d;&#97;&#116;&#x69;&#x6f;&#110;&#x40;&#x62;&#x61;&#105;&#x64;&#x75;&#46;&#x63;&#111;&#109;">&#113;&#x61;&#45;&#97;&#117;&#x74;&#x6f;&#x6d;&#x61;&#116;&#x69;&#x6f;&#x6e;&#x40;&#98;&#97;&#105;&#100;&#x75;&#x2e;&#x63;&#111;&#x6d;</a>&rsquo;
  #   to       &lsquo;<a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#108;&#x65;&#110;&#x67;&#121;&#117;&#64;&#x62;&#x61;&#x69;&#x64;&#x75;&#46;&#99;&#111;&#109;">&#108;&#101;&#x6e;&#x67;&#121;&#117;&#x40;&#x62;&#97;&#x69;&#x64;&#x75;&#x2e;&#99;&#111;&#x6d;</a>&rsquo;
  #   subject  &lsquo;【结算中心线上数据与建忠数据比对结果】&rsquo;
  #   body     @result.to_s
  #   # add_file &lsquo;/full/path/to/somefile.png&rsquo;
  # end</p>

<p>  # 打印结果
  puts @result
  # 断言，@result应该为空。
  @result.should be_empty
end
```</p>

<p>最后看<code>@result</code>是否为空，不是的话，就需要断言。说明2份数据有出入。</p>
]]></content>
  </entry>
  
</feed>
