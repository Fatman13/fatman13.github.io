<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 技术 | Fatman13]]></title>
  <link href="http://Fatman13.github.io/blog/categories/ji-zhu/atom.xml" rel="self"/>
  <link href="http://Fatman13.github.io/"/>
  <updated>2014-02-13T21:40:22+08:00</updated>
  <id>http://Fatman13.github.io/</id>
  <author>
    <name><![CDATA[Fatman13]]></name>
    <email><![CDATA[tctctcly@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何使用小黄瓜来做接口级自动化测试]]></title>
    <link href="http://Fatman13.github.io/blog/2014/02/13/ru-he-shi-yong-xiao-huang-gua-lai-zuo-jie-kou-ji-ce-shi/"/>
    <updated>2014-02-13T21:08:00+08:00</updated>
    <id>http://Fatman13.github.io/blog/2014/02/13/ru-he-shi-yong-xiao-huang-gua-lai-zuo-jie-kou-ji-ce-shi</id>
    <content type="html"><![CDATA[<p>本文将简单介绍如何使用<code>小黄瓜</code>来实现接口级别的自动化测试。如果你还没有对小黄瓜有初步认识的话，推荐阅读我之前写的一篇<a href="http://tauntaunslayer13.me/blog/2014/01/26/ru-he-shi-yong-capybarahe-cucumbershi-xian-ye-mian-ji-bie-zi-dong-hua/">文章</a>。</p>

<!--more-->


<h1>运行自动化</h1>

<p>下载代码，解压，打开命令行，切换到解压后的文件夹中，运行<code>bundle install</code>。<br/>
运行<code>cucumber features/wgpc_check_kai.feature</code>，运行成功的话，应该能看见如下输出。</p>

<p><img src="http://i.imgur.com/ghYr3bJ.jpg" alt="" /></p>

<p>以及其他的一些case等等&hellip;</p>

<h1>feature文档</h1>

<p>用<code>小黄瓜</code>写测试case的第一步就是写case的feature文档。<br/>
例如：<code>cuke_oc\features\wgoc_check_kai.feature</code>。<br/>
<code>小黄瓜</code>的feature文档使用<a href="https://github.com/cucumber/cucumber/wiki/Gherkin">Gherkin</a>格式来更好的帮你理解，管理和维护你的case。</p>

<p>``` cucumber
@checkorder
Feature: Check Order
  为了保证订单的准确性，在提交订单之前，对订单进行验对。</p>

<p>  Background:</p>

<pre><code>Given 我根据"./data/wgoc_cases/shipping_region.txt"设置配送范围
</code></pre>

<p>  Scenario Outline: 验单逻辑</p>

<pre><code>Given 我根据 &lt;mprpc_data_file&gt; 文件中的配置建立运费信息
And 我根据 &lt;mock_data_file&gt; 文件中的配置制造mock商品信息
And 我从 &lt;request_data_file&gt; 文件中读取某http请求
When 我用post方法发送该请求至oc的话
Then 我将得到与 &lt;response_data_file&gt; 文件中相同的json串
</code></pre>

<p>  Examples: case_1: 默认全国10块, 非促销商品验单成功（购买1件&amp;支持配送&lt;上海&amp;北京&amp;天津>&amp;未绑定运费模板）</p>

<pre><code>| mprpc_data_file | mock_data_file | request_data_file | response_data_file |
| empty.json | check_mock_1.yaml | check_request_1.yaml | check_response_1.json |
</code></pre>

<p><code>``
-</code>Feature<code>关键词：简单介绍你要测试的feature。</code>Feature: Check Order<code>的下一行可以跟任意长度的更为详细的功能摘要。一个</code>Feature<code>能包含多个</code>Scenario<code>。（以上例子只有一个</code>Scenario<code>）  
-</code>Backgroud<code>关键词：定义一个全局的setup的步骤。</code>Background<code>对应的代码，整个feature只运行一次。
-</code>Scenario Outline<code>关键词：配合</code>&lt;><code>括号内的变量与</code>Examples<code>关键词，用</code>Examples<code>下面的表格中定义的具体数值来对应到</code>&lt;><code>括号中的变量中的位置。（以上面为例，当这个</code>Scenario<code>被执行的时候，</code>&lt;mprpc_data_file><code>这个参数的数值，就会被</code>Examples<code>中，</code>mprpc_data_file<code>栏中的</code>empty.json<code>替代。）  
-</code>Given<code>关键词：定义case执行时所要做的一些准备工作。  
-</code>When<code>关键词：定义case执行时所要做一个关键动作。  
-</code>Then<code>关键词：定义case执行后，校验工作，一般断言都放在这里。  
-</code>@checkorder<code>关键词：其实这个也不能算是关键词，</code>@checkorder<code>定义了这个feature会使用名为</code>@checkorder`的一个hook。hook定义了这个feature在case级别的setup/teardown应该执行哪儿些代码。</p>

<h1>code block生成</h1>

<p>有了feature文档以后，运行<code>cucumber features/wgpc_check_kai.feature</code>，<code>小黄瓜</code>会帮你生成如下各个关键词对应的code block。（在你还没有定义对应的steps.rb才会生成，参见<code>cuke_oc/features/step_definitions/check_kai_steps.rb</code>。文件命名关系不大，但是一般以steps结尾。）</p>

<p><img src="http://i.imgur.com/JqweeIf.jpg" alt="" /></p>

<p>复制粘帖以上<code>小黄瓜</code>的输出至<code>cuke_oc/features/step_definitions/foo_steps.rb</code>然后就可以开始填写代码了。当case运行时，会按序运行各个code block中的代码。使用除了英文以外的语言时，别忘记在文件顶端加上<code># encoding: utf-8</code></p>

<h1>代码详解</h1>

<p>``` ruby
Given /^我根据 (.*) 文件中的配置建立运费信息$/ do |mprpc_data_file|
  @fid = 0
  @mprpc_res = nil
  # 从mprpc_data_file文件中读取这个case所需要的运费模板参数
  @mprpc_params = JSON.parse(File.read(&lsquo;./data/wgoc_cases/&rsquo; + mprpc_data_file))
  # 向桩发送请求，生成运费模板
  @mprpc_res = RestClient.post JSONRPC_SEND_POSTAGEAPI_ADDTEMPLATE_URI, @mprpc_params.to_json unless @mprpc_params.empty?
  # 从返回中获得运费模板的id
  if !@mprpc_res.nil? &amp;&amp; @mprpc_res.code == 200</p>

<pre><code>@fid = (JSON.parse(@mprpc_res.body))['result']['result']
</code></pre>

<p>  end
end
```</p>

<p>向桩发送请求，并根据<code>mprpc_data_file</code>中的参数，生成运费模板。现在<code>mprpc_data_file</code>用的是yaml格式。使用了<a href="https://github.com/rest-client/rest-client">RestClient</a>这个<code>gem</code>来发送各种<code>http</code>请求。（什么是<a href="http://guides.rubygems.org/">gem</a>?）</p>

<p>``` ruby
Given /^我根据 (.*) 文件中的配置制造mock商品信息$/ do |mock_data_file|
  # 从mock_data_file读取mock商品的参数
  File.open(&lsquo;./data/wgoc_cases/&rsquo; + mock_data_file, &lsquo;r&rsquo;) { |file|</p>

<pre><code>  @mock_params = YAML.load(file.read)
}
</code></pre>

<p>  # 把前面mprpc返回的delivery_id设定为mock商品的fid
  @mock_params[&lsquo;queryInfo&rsquo;][&lsquo;fid&rsquo;] = @fid unless @fid == 0
  # 向桩发送请求，生成mock商品的kv和queryInfo信息
  RestClient.get SCAFFOLDING_CREATE_KV_URI, :params => @mock_params[&lsquo;kv&rsquo;] unless !@mock_params.key?(&lsquo;kv&rsquo;) || @mock_params[&lsquo;kv&rsquo;].nil?
  RestClient.get SCAFFOLDING_CREATE_PRODUCTAPI_QUERYINFO_URI, :params => @mock_params[&lsquo;queryInfo&rsquo;] unless !@mock_params.key?(&lsquo;queryInfo&rsquo;) || @mock_params[&lsquo;queryInfo&rsquo;].nil?
end
```</p>

<p>向商品库的桩发送请求，并根据<code>mock_data_file</code>中的参数，制造mock商品。现在<code>mock_data_file</code>用的是yaml格式。</p>

<p>``` ruby
Given /^我从 (.*) 文件中读取某http请求$/ do |request_data_file|
  # 从request_data_file中读取验单所需的参数信息
  File.open(&lsquo;./data/wgoc_cases/&rsquo; + request_data_file, &lsquo;r&rsquo;) { |file|</p>

<pre><code>  @request_params = YAML.load(file.read)
}
</code></pre>

<p>end
```</p>

<p>读取<code>request_data_file</code>文件中定义的请求信息。</p>

<p><code>ruby
When /^我用post方法发送该请求至oc的话$/ do
  # 向oc发送验单请求
  @last_response = RestClient.get CHECK_REQUEST_URI, :params =&gt; @request_params
end
</code></p>

<p>根据刚刚读取的请求信息，给oc发送验单请求。</p>

<p><code>ruby
Then /^我将得到与 (.*) 文件中相同的json串$/ do |response_data_file|
  # 使用了Rspec提供的should的断言方法
  JSON.parse(@last_response.body).should == JSON.parse(File.read('./data/wgoc_cases/' + response_data_file))
end
</code></p>

<p>跟<code>response_data_file</code>中定义的预期的json串作比较。不相同的话就触发断言。</p>

<h1>总结</h1>

<p>有问题可发送邮件至<code>lengyu@baidu.com</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用Capybara和Cucumber实现页面级别自动化]]></title>
    <link href="http://Fatman13.github.io/blog/2014/01/26/ru-he-shi-yong-capybarahe-cucumbershi-xian-ye-mian-ji-bie-zi-dong-hua/"/>
    <updated>2014-01-26T21:37:00+08:00</updated>
    <id>http://Fatman13.github.io/blog/2014/01/26/ru-he-shi-yong-capybarahe-cucumbershi-xian-ye-mian-ji-bie-zi-dong-hua</id>
    <content type="html"><![CDATA[<p>本文将简单介绍如何使用capybara/cucumber来实现页面级别的自动化。并将结合微购的订单流程做一个讲解。在这儿为大家强烈推讲下<a href="http://pragprog.com/book/hwcuc/the-cucumber-book">The Cucumber Book</a>以及<a href="http://pragprog.com/book/dhwcr/cucumber-recipes">Cucumber Recipes</a>这2本书。几乎包含了关于<code>小黄瓜</code>的一切。<a href="http://product.dangdang.com/23280484.html#ddclick?act=click&amp;pos=23280484_16_1_p&amp;cat=01.00.00.00.00.00&amp;key=Cucumber&amp;qinfo=&amp;pinfo=20_1_72&amp;minfo=&amp;ninfo=&amp;custid=&amp;permid=20140126101508135714985587192225073&amp;ref=http%3A%2F%2Fbook.dangdang.com%2F&amp;rcount=&amp;type=&amp;t=1390702656000">当当网</a>上也有购买，有兴趣的同学可以问我借阅。以下将这2本书简称为<code>小黄瓜全书</code>和<code>小黄瓜食谱</code>。</p>

<!--more-->


<h1>Capybara简介</h1>

<p>Capybara封装了众多帮助页面自动化的函数。极大的简化了开发流程。Capybara的API可参看<code>小黄瓜全书</code>中<code>15.3 The Capybara API</code>章节。</p>

<h1>Cucumber简介</h1>

<p>小黄瓜是一个强大的自动化测试框架。完善的文档，Gherkin式的测试文档，全局/Case级别的setup/teardown，配合Ruby庞大的gem库，支持各种格式report的生成，等等。</p>

<h1>软件安装</h1>

<p>请参看<code>小黄瓜全书</code>里面的Appendix 2: Installing cucumber的章节。以工作机为例，安装以下即可。<br/>
&ndash; <a href="http://rubyinstaller.org/">RubyInstaller</a><br/>
&ndash; <a href="https://github.com/adoxa/ansicon/downloads">ANSICON</a></p>

<h1>运行自动化</h1>

<p>下载代码，解压，打开命令行，切换到解压后的文件夹中，运行<code>bundle install</code>，修改<code>cuke_pc/features/step_definitions/cod_steps.rb</code>，把以下登录信息改为你自己的百度账号和密码。</p>

<p><code>ruby
fill_in 'userName', :with =&gt; '在此输入你的百度账号'
fill_in 'TANGRAM__PSP_4__password', :with =&gt; '在此输入你的百度帐号密码'
</code></p>

<p>运行<code>cucumber features/wgpc_cod.feature</code>，自动化就跑起来了！</p>

<h1>代码讲解</h1>

<p>在这个<code>cucumber features/wgpc_cod.feature</code>自动化Case中，<br/>
代码都在<code>cuke_pc/features/step_definitions/cod_steps.rb</code>里面。为大家详解一下<code>cod_steps.rb</code>中的代码。</p>

<p><code>ruby
Given /^我已登录用户中心$/ do
  # 访问个人中心页面
  visit 'http://zhixin.baidu.com/Login/index?module=onesite&amp;u=http%3A%2F%2Fcp01-testing-cbbs06.cp01.baidu.com%3A8888%2Fitem%3Fid%3D181835090&amp;from='
  # 在登录页面中，输入自己的百度账号
  fill_in 'userName', :with =&gt; '在此输入你的百度账号'
  # 输入自己百度账号密码
  fill_in 'TANGRAM__PSP_4__password', :with =&gt; '在此输入你的百度帐号密码'
  # 点击登录
  click_button 'TANGRAM__PSP_4__submit'
end
</code></p>

<p><code>visit</code>函数: 根据配置，自动打开网页浏览器，并访问参数中指定的url。<br/>
<code>fill_in</code>函数: 根据id,name或者label text找到输入框，并填写参数所指定的String。<br/>
<code>click_button</code>函数: 根据id,name或者label text找到按钮，并点击该按钮。<br/>
以上代码实现的是，首先打开火狐，进入个人中心页面，输入用户名密码，并点击登录。</p>

<p><code>ruby
Given /^我在中间页对"(.*?)"商品下单:一$/ do |arg1|
  # 这个暂时不关注
  @expected_time_range = Time.now .. (Time.now + 600)
  # 点击立即购买
  find('#detail-buy').click
  # 浏览器窗口最大化
  page.driver.browser.manage.window.maximize
end
</code></p>

<p><code>find</code>函数: 根据CSS Selector或者Xpath找到对应的元素。以便于更进一步的操作。<br/>
以上代码实现的是，在中间页，点击<code>立刻购买</code>。</p>

<p><code>ruby
When /^我选取货到付款$/ do
  # 根据lablel元素上的字，找到“货到付款”并点击
  find("label", :text =&gt; /\A货到付款\z/).click
  # 等待“提交订单”的出现
  find('.order-summary-submit')
  # 点击“提交订单”
  find('.order-summary-submit').click
  # 通过xpath，找到查看所有订单按钮，并点击
  find(:xpath, "//a[@href='/service/user/order/list']").click
end
</code></p>

<p>以上代码实现的是，在验单页面，点击<code>货到付款</code>，点击<code>提交订单</code>，点击<code>查看订单</code>。注意，如果提交订单失败的话，这个case就会在这儿挂掉。</p>

<p><code>ruby
Then /^个人中心订单状态被告更改为"(.*?)"$/ do |arg1|
  # 这个暂时不关注
  puts find(:xpath, "(//td[@class='time'])[1]").text
  @order_time = DateTime.strptime(find(:xpath, "(//td[@class='time'])[1]").text, '%Y-%m-%d %H:%M:%S')
  puts @expected_time_range.cover?(@order_time)
  # 使用xpath，找到之前下的订单，并比较订单状态是否是“等待发货”
  find(:xpath, "(//span[@class=' status_confirm'])[1]").should have_content(arg1)
end
</code></p>

<p><code>should</code>函数: RSpec里面的一个断言的方法。<br/>
<code>have_content</code>函数: 判定元素中是否存在参数中的字段。<br/>
以上代码实现的是，回到个人中心后，比较最近的一个订单是不是处于<code>等待发货</code>状态，如果状态错误Case就会挂掉。</p>

<h1>总结</h1>

<p><code>Capybara/Cucumner</code>是一个有完善文档的，非常强大的测试框架。希望以后能用于主流程的保证。不知道医疗那边的同学需不需要？无论是测死链，或者是ajax也都完全没有问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How-to: Host rails app on OpenShift for FREE]]></title>
    <link href="http://Fatman13.github.io/blog/2013/09/16/how-to-host-rails-app-on-openshift-for-free/"/>
    <updated>2013-09-16T14:39:00+08:00</updated>
    <id>http://Fatman13.github.io/blog/2013/09/16/how-to-host-rails-app-on-openshift-for-free</id>
    <content type="html"><![CDATA[<p>There are many great options for hosting your rails application. For instances, <a href="http://en.wikipedia.org/wiki/Platform_as_a_service">PaaS</a> like <a href="https://www.engineyard.com/">engine yard</a> and <a href="https://www.heroku.com/">heroku</a> provide great scalability and automations to ease your deployment. VPS like <a href="https://www.linode.com/">Linode</a> provides more traditional hosting services, which gives you full control of a node. But what if you just want to test your idea and have a public domain name (no tunneling and router tricks)? Then OpenShift is a great choice, cause it is FREE! (at least for your first 3 gears)</p>

<!--more-->


<h1>Good Resources</h1>

<ul>
<li><p>Official rails quick starter <a href="https://www.openshift.com/kb/kb-e1005-ruby-on-rails-openshift-quickstart-guide">guide</a>.</p></li>
<li><p>Official sample rails app on <a href="https://github.com/openshift-quickstart/rails-sunspot-openshift-quickstart">github</a>.</p></li>
<li><p>Official documentation on deployment <a href="http://openshift.github.io/documentation/oo_cartridge_developers_guide.html#openshift-builds">scripts</a>.</p></li>
<li><p>Deployment tutorial <a href="http://ror-tech.blogspot.com/2013/04/deploying-rails-application-on-to.html">guide</a>.</p></li>
</ul>


<h1>Deployment</h1>

<p><em>This guide will be similar to steps described in the resouces mentioned above. I will add my thoughts to some of the steps.</em></p>

<p><strong>1</strong>. Create an <a href="http://www.openshift.com">OpenShift</a> account.</p>

<p><strong>2</strong>.  Install <code>rhc</code> gem. (If you are using <code>rvm</code>, don’t use <code>sudo</code>.)
<code>
gem install rhc
</code></p>

<p><strong>3</strong>. Create your cartridge. This should create a folder called <code>[your_rails_app_name]</code> at <code>.</code>.
<code>
rhc app create -a [your_rails_app_name] -t ruby-1.9
</code></p>

<p><strong>4</strong>. Add database support to your application.
<code>
rhc cartridge add -a [your_rails_app_name] -c [database_name]
</code>
Here is a list of supported database.</p>

<table>
<thead>
<tr>
<th align="left">Short Name </th>
<th align="left"> Full name</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">10gen-mms-agent-0.1 </td>
<td align="left"> 10gen Mongo Monitoring Service Agent</td>
</tr>
<tr>
<td align="left">cron-1.4 </td>
<td align="left"> Cron 1.4</td>
</tr>
<tr>
<td align="left">jenkins-client-1 </td>
<td align="left"> Jenkins Client</td>
</tr>
<tr>
<td align="left">mongodb-2.2 </td>
<td align="left"> MongoDB NoSQL Database 2.2</td>
</tr>
<tr>
<td align="left">mysql-5.1 </td>
<td align="left"> MySQL Database 5.1</td>
</tr>
<tr>
<td align="left">metrics-0.1 </td>
<td align="left"> OpenShift Metrics 0.1</td>
</tr>
<tr>
<td align="left">haproxy-1.4 </td>
<td align="left"> OpenShift Web Balancer</td>
</tr>
<tr>
<td align="left">phpmyadmin-3 </td>
<td align="left"> phpMyAdmin 3.4</td>
</tr>
<tr>
<td align="left">postgresql-8.4 </td>
<td align="left"> PostgreSQL Database 8.4</td>
</tr>
<tr>
<td align="left">postgresql-9.2 </td>
<td align="left"> PostgreSQL Database 9.2</td>
</tr>
<tr>
<td align="left">rockmongo-1.1 </td>
<td align="left"> RockMongo 1.1</td>
</tr>
<tr>
<td align="left">switchyard-0 </td>
<td align="left"> SwitchYard 0.8.0</td>
</tr>
</tbody>
</table>


<p><strong>5</strong>. Add <code>deploy</code> script to <code>[your_rails_app_name]/.openshift/action_hooks/</code>.
<code>
touch [your_rails_app_name]/.openshift/action_hooks/deploy
</code>
Add the following code to <code>deploy</code> file to initialize database.
<code>ruby
pushd ${OPENSHIFT_REPO_DIR} &gt; /dev/null
bundle exec rake db:migrate RAILS_ENV="production"
popd &gt; /dev/null
</code>
<em>NOTE: This might be obvious to experienced Linux user, but I failed to realize this the first time. You have to do a <code>sudo chmod +x [your_rails_app_name]/.openshift/action_hooks/deploy</code> on your <code>deploy</code> script or it won’t be run by the server.</em></p>

<p><strong>6</strong>. Change production database configuration in <code>config/database.yml</code>. Then submit your change to your <a href="https://github.com/">github</a> repository.
``` yaml</p>

<p>production:
  adapter: mysql2
  encoding: utf8
  reconnect: false
  pool: 5
  database: &lt;%=ENV[&lsquo;OPENSHIFT_APP_NAME&rsquo;]%>
  username: &lt;%=ENV[&lsquo;OPENSHIFT_MYSQL_DB_USERNAME&rsquo;]%>
  password: &lt;%=ENV[&lsquo;OPENSHIFT_MYSQL_DB_PASSWORD&rsquo;]%>
  socket: &lt;%=ENV[&lsquo;OPENSHIFT_MYSQL_DB_SOCKET&rsquo;]%>
  host: &lt;%=ENV[&lsquo;OPENSHIFT_MYSQL_DB_HOST&rsquo;]%>
  port: &lt;%=ENV[&lsquo;OPENSHIFT_MYSQL_DB_PORT&rsquo;]%>
<code>``
*NOTE: Remember to change adapter and ENV variable to corresponding database your are using. For example, If your are using postgresql then change</code>&lt;%=ENV[&lsquo;OPENSHIFT_MYSQL_DB_USERNAME&rsquo;]%><code>to</code>&lt;%=ENV[&lsquo;OPENSHIFT_POSTGRESQL_DB_USERNAME&rsquo;]%>`*</p>

<p><strong>7</strong>. Download your rails application from your github repository.
<code>
cd railsapp
git remote add upstream -m master [your_git_repo_ssh_url]
git pull -s recursive -X theirs upstream master
</code></p>

<p><strong>8</strong>. Do <code>git push</code>. <code>git push</code> will initialize the server and trigger the <code>deploy</code> script. If everything goes alright, you should see your application running on <code>http://[your_rails_app_name]-[your_namespace].rhcloud.com</code>. You can customize your domain name too. Check this <a href="http://ror-tech.blogspot.com/2013/04/deploying-rails-application-on-to.html">post</a> out to learn details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写给毛藏的使用指南]]></title>
    <link href="http://Fatman13.github.io/blog/2013/09/03/xie-gei-mao-cang-de-shi-yong-zhi-nan/"/>
    <updated>2013-09-03T16:46:00+08:00</updated>
    <id>http://Fatman13.github.io/blog/2013/09/03/xie-gei-mao-cang-de-shi-yong-zhi-nan</id>
    <content type="html"><![CDATA[<p>写给毛藏的使用指南。</p>

<!--more-->


<h1>如何安装</h1>

<p><strong>1</strong>. 下载并安装<a href="http://files.rubyforge.vm.bytemark.co.uk/railsinstaller/railsinstaller-2.2.1.exe">RailsInstaller</a>。</p>

<p><strong>2</strong>. 安装完成之后，应该会有一个<code>命令行</code>跳出来。输入以下指令。</p>

<p><code>
git clone https://github.com/Fatman13/MaoZangLED.git
cd MaoZangLED
bundle install
rake db:migrate
</code></p>

<p><em>注：如果有除了c盘以外其他分盘的话需要替换</em><code>bundle install</code><em>为</em><code>bundle install --path .bundle</code><em>。好像sass在windows上有bug。</em></p>

<p><strong>3</strong>. 至此安装完成。运行<code>rails s</code>，使用本地服务器。</p>

<p><strong>4</strong>. 打开浏览器。输入地址<code>localhost:3000/products</code>。</p>

<h1>如何打开服务器</h1>

<p><strong>1</strong>. 打开命令行</p>

<p><code>
cd c:\Sites\MaoZangLED
rails s
</code></p>

<h1>如何更新</h1>

<p><strong>1</strong>. 使用以下命令更新代码。</p>

<p><code>
cd c:\Sites\MaoZangLED
git fetch --all
git reset --hard origin/master
bundle install --path .bundle
rake db:migrate
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How-to: Develop a RubyGem using Bundler]]></title>
    <link href="http://Fatman13.github.io/blog/2013/08/12/how-to-develop-a-rubygem-using-bundler/"/>
    <updated>2013-08-12T15:08:00+08:00</updated>
    <id>http://Fatman13.github.io/blog/2013/08/12/how-to-develop-a-rubygem-using-bundler</id>
    <content type="html"><![CDATA[<p>I am by no means a Ruby expert. This is my humble attempt of sharing what I have learned and serves as a note to future me. It should be helpful to whoever is new to Ruby and would like to have a jump start on developing a Ruby gem.</p>

<!--more-->


<h1>Prerequisites</h1>

<h3>Ruby</h3>

<p>Ruby is a powerful programming language which gains popularity with the rise of many active open source projects and communities built around it. Before thinking build some library from scratch, there might already be a free open source library which you can easily leverage. Therefore saving tons of development time.</p>

<h3>gem</h3>

<p>A <code>gem</code> is a Ruby library packaged in a standard format. You can easily download and install gems to help your development through RubyGems, which will be discussed later in the article. In a nutshell, RubyGems works a lot like <code>apt</code> or <code>yum</code>.</p>

<h3>rvm</h3>

<p><code>rvm</code> stands for Ruby enVironment Manager. <code>rvm</code> allows you to switch to a specific Ruby version and a specific set of gems for different projects. It is highly recommended that you install <code>rvm</code> to manage different versions of Ruby and gemsets for your projects.</p>

<p>To install <code>rvm</code>, do.</p>

<p><code>
curl -L https://get.rvm.io | bash -s stable –ruby
</code></p>

<p>To install Ruby 1.9.3, do.</p>

<p><code>
rvm install 1.9.3
rvm use 1.9.3
rvm rubygems latest
</code></p>

<p>Use <code>rvm list</code> to verify your Ruby installation. Use <code>rvm list known</code> to see a list of available Ruby versions that rvm is capable of installing.</p>

<p>Notice the last command <code>rvm rubygems lastest</code> will install latest version of <code>rubygems</code>, which is a Ruby library packaging and distribution manager.</p>

<h3>RubyGems</h3>

<p>As mentioned above, with RubyGems, installing libraries published by others is made very easy.</p>

<p><code>
gem install [gem_name]
</code></p>

<p>Substitute [gem_name] in above command to install the actual gem you want.</p>

<ul>
<li><p><strong>Note</strong>: A gem may depend on other gems. Therefore installing one gem may result in installing multiple other gems.</p></li>
<li><p><strong>Tip</strong>: You can specify which version of the gem you want to install by <code>gem install [gem_name] -v ‘1.0.0’</code>,  <code>gem install [gem_name] -v ‘&gt;=1.0.0’</code>, or <code>gem install [gem_name] -v ‘~&gt;1.0.0’</code></p></li>
<li><p><strong>Important</strong>: If you are using <code>rvm</code> like many people recommended, <strong>DO NOT</strong> use <code>sudo</code> when installing gems. You may come across many tutorials telling you to do things like <code>sudo gem install devise</code>. <strong>DON’T</strong> do that. Because <code>sudo</code> will mess up your <code>rvm</code>. See more details on why not using <code>sudo</code> <a href="http://rvm.io/rubies/rubygems">here</a> if you are interested.</p></li>
</ul>


<h3>Git</h3>

<p>Install git, do.</p>

<p><code>
sudo apt-get install git
</code></p>

<!--p2-->


<h1>Building your first gem using Bundler</h1>

<p><code>Bundler</code> is a great gem which can do a lot of things. Scaffolding a new gem is one of its many features.</p>

<p>I will be using <a href="https://github.com/Fatman13/ColorfulMD">colorfulMD</a> as an example gem for this walk through. ColorfulMD colorfies your markdown text by adding <code>&lt;font color=”a_color”&gt;&lt;/color&gt;</code> tag to certain text defined in a <code>config.yaml</code> file.</p>

<p><em>There is a very good guide <a href="https://github.com/radar/guides/blob/master/gem-development.md">here</a>. I will be explaining things that might not be too obvious. At least not so obvious to me.</em></p>

<h3>Getting started</h3>

<p>To install Bundler, do.</p>

<p><code>
gem install bundler
</code></p>

<p>To create a new gem, do.</p>

<p><code>
bundle gem colorfulMD
</code></p>

<p>This should create a new folder called <code>colorfulMD</code>. Some skeleton files and directories will be created under <code>./colorfulMD</code>.</p>

<blockquote><p>If you have Git installed, <code>bundle gem colorfulMD</code> also initializes a Git repository in <code>./colorfulMD</code> so you can start committing right away.</p></blockquote>

<ul>
<li><p><strong>Tip</strong>: You can add <code>.*~</code> and <code>*~</code> to <code>.gitignore</code> file if your text editor creates tmp file ending with <code>~</code>. This will prevent unnecessary files get pushed into your repo.</p></li>
<li><p><strong>Tip</strong>: If you are using IDEs like <code>RubyMine</code>. You may also want to add <code>.idea</code> to your <code>.gitignore</code> file.</p></li>
<li><p><strong>Tip</strong>: Usually you can define all your gem dependencies in your <code>Gemfile</code>. But <code>Bundler</code> creates <code>[gem_name].gemspec</code> file by default and defines dependencies there.</p></li>
<li><p><strong>Tip</strong>: It is a good practice that you put a <code>.rvmrc</code> like <a href="https://github.com/Fatman13/ColorfulMD/blob/master/.rvmrc">this one</a> in <code>colorfulMD</code> folder. <code>cd</code> out of <code>colorfulMD</code> folder and <code>cd</code> back in, you should see that <code>rvm</code> will initialize a independent Ruby environment for this project. This means when working in <code>colorfulMD</code> folder, you are using different Ruby version or gemsets than the global ones.</p></li>
</ul>


<h3>Following BDD</h3>

<p>I didn’t find <a href="http://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a> particularly intriguing. But as for this walk through, we shall start writing our test cases even before any actual coding following BDD discipline.</p>

<p>Open <code>colorfulMD.gemspec</code> file and add the following. (<a href="https://github.com/Fatman13/ColorfulMD/blob/master/colorfulMD.gemspec">example here</a>)</p>

<p><code>ruby
s.add_development_dependency "cucumber"
s.add_development_dependency "aruba"
</code>
(<em><code>add_development_dependency</code> means those gems will only be installed for development use.</em>)</p>

<p><code>cucumber</code> gem and <code>aruba</code> gem are great testing tools help us generate test code following BDD discipline. (<em><a href="http://blog.jcoglan.com/2009/10/03/getting-started-with-cucumber-rspec-webrat-and-multiruby/">here</a> is a pretty good introductive tutorial for <code>cucumber</code></em>) <code>bundle install</code> is a command that goes through gemspec file, figure out the dependency and installs gems needed.</p>

<p>Run <code>bundle install</code> to install dependencies.</p>

<p>Inside <code>colorfulMD</code>, do <code>mkdir features</code>. <code>cd</code> into <code>features</code> and create directory structure and files like shown <a href="https://github.com/Fatman13/ColorfulMD/tree/master/features">here</a>.</p>

<ul>
<li><p><strong>/support</strong>: Ruby files in <code>support</code> folder will be executed before <code>cucumber</code> runs any actual tests, therefore it is good to put code that sets up environment here.</p></li>
<li><p><strong>/step_definitions</strong>: Actual test code for a feature will be in this folder.</p></li>
<li><p><strong>cli.feature</strong>: Write your feature in this file. You can name it differently.</p></li>
</ul>


<p>I put down the following into my <code>cli.feature</code> file.</p>

<p>``` ruby
Feature: CLI
  In order to colorfy markdown
  As a CLI
  I want to add <font color> tag to some text</p>

<p>  Scenario: add <font color="given_color"> tag to &ldquo;given_string&rdquo;</p>

<pre><code>Given three arguments "given_color", "given_string" and "text"  
When I call colorfy of CLI with "red" "apple" in "I had an apple this afternoon" 
Then the output should equal 
  """
  I had an &lt;font color="red"&gt;apple&lt;/font&gt; this afternoon
  """
</code></pre>

<p>```</p>

<p>It doesn’t seem to really matter what you put right after <code>Feature:</code> and <code>Scenario:</code>.  The main thing you want to define here is what follows <code>Given</code>, <code>When</code> and <code>Then</code> keywords. It is relatively comprehensive. <code>Given</code> defines what argument(s) your method is taking. (<em>you don’t need <code>given</code> if you are not going to do anything fancy with the arguments</em>) I specified values of the three arguments with <code>When</code> keyword. Note how close the test case is to natural language. That is supposed to be the beauty of BDD. Given the arguments specified after <code>When</code>, I put down the expected output after <code>Then</code> keyword. Triple quotes was used for escaping the quotes in the expected output.</p>

<p>After all that, run <code>bundle exec cucumber features/</code>.  Copy paste the output after <code>You can implement step definitions for undefined steps with these snippets:
</code> to <code>/step_definitions/colorfy_steps.rb</code>. (<em>you should copy paste something close to the below</em>)</p>

<p>``` ruby
Given(/^three arguments &ldquo;(.<em>?)&rdquo;, &ldquo;(.</em>?)&rdquo; and &ldquo;(.*?)&rdquo;$/) do |arg1, arg2, arg3|
  pending # express the regexp above with the code you wish you had
end</p>

<p>When(/^I call colorfy of CLI with &ldquo;(.<em>?)&rdquo; &ldquo;(.</em>?)&rdquo; in &ldquo;(.*?)&rdquo;$/) do |arg1, arg2, arg3|
  pending # express the regexp above with the code you wish you had
end</p>

<p>Then(/^the output should equal$/) do |string|
  pending # express the regexp above with the code you wish you had
end
<code>``
Now add some actual testing code to</code>colorfy_steps.rb` like shown <a href="https://github.com/Fatman13/ColorfulMD/blob/master/features/step_definitions/colorfy_steps.rb">here</a>.</p>

<h3>Implementing CLI</h3>

<p>Add <code>spec.add_dependency "thor"</code> to your <code>gemspec</code> file. And run <code>bundle install</code>.</p>

<p>At project root, do <code>mkdir lib/colorfulMD</code>, <code>touch lib/colorfulMD/cli.rb</code> and <code>touch lib/colorfulMD/colorfulMD.rb</code>. Paste the following to <code>cli.rb</code> and <code>colorfulMD.rb</code> respectively.</p>

<p>``` ruby</p>

<h1>$LOAD_PATH.unshift(File.dirname(<strong>FILE</strong>))</h1>

<p>require &lsquo;thor&rsquo;
require &lsquo;colorfulMD&rsquo;</p>

<p>module ColorfulMD
  class CLI &lt; Thor</p>

<pre><code>desc "colorfy GIVEN_COLOR GIVEN_STRING TEXT", "colorfy a given word by a given color defined in yaml"
def colorfy(given_color, given_string, text)
    clrmd = ColorfulMD::Colorfulmd.new
    clrmd.colorfy(given_color, given_string, text)
end  
</code></pre>

<p>  end
end
```</p>

<p>``` ruby
module ColorfulMD</p>

<pre><code>class Colorfulmd
    # colorfy
    def colorfy(given_color, given_string, text)
      text.gsub(given_string, "&lt;font color=\"" + given_color + "\"&gt;" + given_string + "&lt;/font&gt;" )
    end      
end
</code></pre>

<p>end
```</p>

<p>At this point, if you run <code>bundle exec cucumber features</code>, you should see you have passed all cucumber test! Systems all green!</p>

<p>And now we just need to make a cli executable.</p>

<p>At project root, do <code>mkdir bin</code>. Do <code>touch bin/colorfulMD</code> and <code>sudo chmod +x bin/colorfulMD</code>. <code>bin/colorfulMD</code> will be your CLI executable for your gem. Paste the following code to <code>bin/colorfulMD</code></p>

<p>``` ruby</p>

<h1>!/usr/bin/env ruby</h1>

<p>$LOAD_PATH.unshift(File.dirname(<strong>FILE</strong>) + &lsquo;/../lib/colorfulMD&rsquo;)
require &lsquo;colorfulMD/cli&rsquo;
require &lsquo;colorfulMD&rsquo;
ColorfulMD::CLI.start
```</p>

<p>Run your executable by <code>bundle exec bin/colorfulMD colorfy red apple apple</code>. You can modify the code to have colorfy method output string by replacing <code>text.gsub(given_string, "&lt;font color=\"" + given_color + "\"&gt;" + given_string + "&lt;/font&gt;" )</code> with <code>puts text.gsub(given_string, "&lt;font color=\"" + given_color + "\"&gt;" + given_string + "&lt;/font&gt;" )</code> in <code>colorfulMD.rb</code>.</p>

<p>This concludes the tutorial.</p>
]]></content>
  </entry>
  
</feed>
